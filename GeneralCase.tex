\section{Общий алгоритм}

Понятно, что тривиальный алгоритм (пробовать все возможные нумерации одного из графов, пока они не закончатся, либо графы не совпадут) работает за $O(n!)$, так как $|Aut(V)| = n!$. Современные результаты таковы: есть алгоритм Бабаи и Лакса, работающий за время $2^{O(\sqrt{nlog(n)})}$ \cite{12}. Данный алгоритм опирается на теорему о классификации простых конечных групп. Без этой теоремы он тоже работает, но оценка его времени работы увеличивается. В 2017 году Бабаи представил последнюю версию своего квазиполиномиального алгоритма, но этот алгоритм ещё не был проверен \cite{13}. Последний алгоритм так же опирается на теорему о классификации простых конечных групп. Он описан в статье на 89 страниц. У меня нет возможности описать ни один из этих сложных алгоритмов, поэтому я опишу другой, чуть менее сложный, но всё же субфакториальный.

\subsubsection*{Предисловие к алгоритму}

Мы вновь рассмотрим несколько модифицированную проблему изоморфизма графов:

Пусть $G_1=(V, E), G_2=(VV, EE)$ - два графа. Пусть также $\tau = (V_1, ..., V_l), \sigma = (VV_1, ..., VV_l)$ -отношения эквивалентности на на $V_1, V_2$ соответственно. Тогда от изоморфизма $\phi$ дополнительно требуется, чтобы для любого $i \in \{i, ..., l\}$ выполнялось $\phi(V_i) = VV_i$

Понятно, что стандартная проблема изоморфизма - это частный случай нашей: можно взять отношения эквивалентности, где все равны.

\begin{definition}
    Пару $A, B \in V$ назовём безразличной, если либо $\forall a \in A, b \in B \quad (a, b) \notin E$, либо $\forall a \in A, b \in B \quad (a, b) \in E$
\end{definition}

\begin{definition}
    Обозначим за $E(x)$ все вершины, соединённые с $x$
\end{definition}

\begin{definition}
    Обозначим за $v_{\tau}(x) = (v_1(x), ..., v_n(x))$, где $x \in V$, $\tau = (V_1, ..., V_l)$ - это отношение эквивалентности на $V$, а $v_i(x) = |E(x) \cap V_i|$
\end{definition}

\begin{definition}
    Отношение эквивалентности $\tau$ назовём стабильным, если $x \tau y \Rightarrow v_{\tau}(x) = v_{\tau}(y)$, где $x \tau y = 1$, если $x$ эквивалентен $y$ относительно $\tau$ и 0 иначе.
\end{definition}

\begin{definition}
    Стабильную эквивалентность $\tau^*$ назовём замыканием $\tau$, если  $\tau^* \leqslant \tau^*$ и для любого стабильного $\sigma$ такого, что $\sigma \leqslant \tau$ верно, что $\sigma \leqslant \tau^*$
\end{definition}

\begin{definition}
    Подмножество вершин $S$ назовём секцией $G$ относительно $\tau = (V_1, ..., V_l)$, если для любых $i, j \in \{1, ..., l\}$ верно, что пара $V_i \cap S, V_j \text{\textbackslash} S$ - безразлична. Вектор $q(S)=(S \cap V_1, ..., S \ cap V_l)$ назовём вектором секции. Обозначим множество неотсортированных пар $(x, y)$, где $x \in V_i \cap S, y \in V_j \text{\textbackslash} S$ через $S_{i, j}$. Тогда матрицу $M = (m_{i, j})$,\\ 
    $m_{i, j} = 
    \begin{cases}
        1, \text{если } S_{i, j} \cup S_{j, i} \neq \emptyset \text{ И } S_{i, j} \cup S_{j, i} \subset E\\
        0, \text{если } S_{i, j} \cup S_{j, i} \neq \emptyset \text{ И } S_{i, j} \cup S_{j, i} \cap E = \emptyset\\
        undefined,  \text{если} S_{i, j} \cup S_{j, i} = \emptyset\\
    \end{cases}$\\
    назовём матрицей секции. 
\end{definition}

Например, если $I$ - это все классы $\tau$ из одной вершины, то если $B \subset I$, $C \supset  V \text{\textbackslash} I$, то $B, C$ - секции относительно $\tau$. Такие секции будем называть тривиальными. Если нетривиальная секция $S$ содержит нетривиальную секцию $T \neq S$ такую, что $M(T) = M(S)$, назовём её минимальной.

\begin{theorem}
    Пусть $\tau, \sigma$ - стабильные эквивалентности. Графов $G, H$ соответственно. Тогда если $S$ - секция относительно $\tau$, то

    1. Если $\phi$ - изоморфизм $(G, \tau) \rightarrow (H, \sigma)$, то $\phi(S)$ - секция относительно $\sigma$

    2. Если $T$ - секция $H$ относительно $\sigma$, такая, что $M(S) = M(T)$, то любые изоморфизмы $\phi_1=(S, \tau(S)) \rightarrow (T, \sigma(T), \phi_2=(G \text{\textbackslash} S, \tau(G\text{\textbackslash} S)) \rightarrow (H\text{\textbackslash} T, \sigma(H\text{\textbackslash} T))$ образуют изоморфизм $\phi = \phi_1 \cup \phi_2$ 

    3. Если $M(S) = M(T)$ и пары $(G, \tau), (H, \sigma)$ и $(S, \tau(S)), (T, \sigma(T))$ - изоморфны, то пара $(G \text{\textbackslash} S, \tau(G\text{\textbackslash} S)), (H\text{\textbackslash} T, \sigma(H\text{\textbackslash} T))$ тоже изоморфна.
\end{theorem}

\subsubsection*{Алгоритм}

Считаем, что все эквивалентности стабильны. В противном случае можно использовать замыкание эквивалентности, которое можно найти за полиномиальное время.

Назовём класс эквивалентности эффективым, если его размер больше единицы.

Пусть изначальная задача - проверить на изоморфизм пары $(G, \tau), (H, \sigma)$. 

Найдём все минимальные секции(это можно сделать за полином, но для наших целей подойдёт и проверка в лоб за $2^n$) $(S_1, ..., S_k)$ в $G$ и $(T_1, ..., T_k)$ в $H$ и разделим на подмножества согласно их секционным векторам. Пусть $A_i = \{S_{i, 1}, ..., S_{i, p_{i}}\}$  $B_i = \{T_{i, 1}, ..., T_{i, p_{i}}\}$, $v(S_{i, j}=T_{i, j}) = v_i$, где $i \in \{1, ..., q\}$

Понятно, что $S = \cup_{i=1}^q \cup_{j=1}^{p_i}S_{i, j}$ и $S_{i, j} \cap S_{i', j'} = \emptyset$, если $(i, j) \neq (i', j')$.

Теперь согласно Теореме 2, мы можем рабить исходную задачу на ряд более мелких подзадач $K_1, ..., K_q$. Рассмотрим, например $K_1$: для $S_{i, 1}$ решаем задачи проверки на изоморфизм таких пар:

$P_{i, 1}=((S_{i, 1}, \tau(S_{i, 1})), (T_{i, 1}, \sigma(i, 1)))$, ..., $P_{i, t}=((S_{i, t}, \tau(S_{i, t})), (T_{i, t}, \sigma(i, t)))$,

где $t$ - первая задача, ответ на которую "да"\,. Выкидываем $S_{i, 1}. T_{i, 1}$ из $A_i, B_i$ соответственно и повторям процесс для $S_{i, 2}$. Ответ на изначальную задачу - "да"\, тогда и только тогда, когда для каждого $i$ найдётся $t_i$ такой, что ответ на задачу $P_{i, t_i}$ - "да"\,. Каждую задачу из $P_{i, j}$ разбиваем аналогичным образом. В конце концов мы приходим к набору проблем, для которых невозможно найти минимальные секции. Назовём этот набор $Ex(P)$. Замечу, что возможна ситуация, когда $P=Ex(P)$, и описанная только что часть алгоритма пропускается.

Теперь строим изоморфизм ввиде дерева: корень будет фиктивным и назовём мы его $Z_0$. Затем каждой проблеме $Z$ в $Ex(P)$(и одновременно узлу в нашем дереве) добавит в качестве детей $Ex(Re(Z))$, где $Re(P) = \{P_i=[(G, \tau_{x_i}^*), (H, \sigma_{y_i}^*)]\}$. И через некоторое количество повторений все эквивалентности превратятся в тривиальные, где никто никому не равен, что эквивалентно заранее заданной нумерации и проверяется за линию.

\subsubsection*{Послесловие к алгоритму}

Этот алгоритм представлен в \cite{14} и там же показано, что его время работы - $O(c^n)$, где $c$ - некоторая константа.
