\subsection{Безымянный класс}

Приведённый ниже алгоритм проверяет изоморфизм двух графов, принадлежащих некоему классу $K$. По сути, сам алгоритм и задаёт этот класс. 

\subsubsection*{Предисловие к алгоритму}
На первый взгляд может показаться, что алгоритм этот бесполезен, но на самом деле, класс $K$ состоит из почти всех графов. В \cite{14} показано, что вероятность того, что процедура 1-6 успешно завершится на случайном графе не меньше, чем $1-(\frac{1}{n})^{\frac{1}{7}}$ начиная с некоторого $n$, а значит она стремится к единице при стремлении $n$ к бесконечности.

\subsubsection*{Алгоритм}

0. Для обоих алгоритмов повторить пункты 1-6.

1. Для каждой вершины $v$ посчитать $d(v)$ - её степень.

1. Упорядочить вершины по значенийм $d(v)$, то есть теперь $d(1) \geqslant d(2) \geqslant ... \geqslant d(n)$

2. Обозначим $k = [3log_2n]$. Если существует вершина $v_i: i < k$ и $d(i) = d(i + 1)$, то завершаемся неудачей.

3. Для каждого $i \in \{k+1, ..., n\}$ считаем бинарный вектор $f(i) = (e_1, ..., e_k)$, где $e_j = 1 \leftrightarrow (i, j) \in E$

4. Переупорядочим вершины $v_i$ с номерами большими, чем $k$ по $f(i)$. То есть $f(k + 1) \geqslant ... \geqslant f(n)$

5. Если существует $i: f(i) = f(i + 1)$, завершаемся неудачей.

6. Мы получили каноническую нумерацию.

7. Графы изоморфны $\Leftrightarrow$ их канонические нумерации совпадают.

\subsubsection*{Послесловие к алгоритму}

Понятно, что если алгоритм завершился, то завершился он за квадратичное от количества вершин время, то есть за линейное от размера графа в модели с произвольным доступом, если представлять его матрицей смежности. В других представлениях, время может стать квадратичным от входа. 
